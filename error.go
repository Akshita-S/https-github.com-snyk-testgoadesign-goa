// Package goa standardizes on structured error responses: a request that fails because of
// invalid input or unexpected condition produces a response that contains one or more structured
// error(s). Each error object has three keys: a id (number), a title and a message. The title
// for a given id is always the same, the intent is to provide a human friendly categorization.
// The message is specific to the error occurrence and provides additional details that often
// include contextual information (name of parameters etc.).
//
// The basic data structure backing errors is TypedError which simply contains the id and message.
// Multiple errors (not just TypedError instances) can be encapsulated in a MultiError. Both
// TypedError and MultiError implement the error interface, the Error methods return valid JSON
// that can be written directly to a response body.
//
// The code generated by goagen calls the helper functions exposed in this file when it encounters
// invalid data (wrong type, validation errors etc.) such as InvalidParamTypeError,
// InvalidAttributeTypeError etc. These methods take and return an error which is a MultiError that
// gets built over time. The final MultiError object then gets serialized into the response and sent
// back to the client. The response status code is inferred from the type wrapping the error object:
// a BadRequestError produces a 400 status code while any other error produce a 500. This behavior
// can be overridden by setting a custom ErrorHandler in the application.
package goa

import (
	"fmt"
	"strings"
)

type (
	// HTTPError describes an error that can be returned in a response.
	HTTPError struct {
		// Class of error
		*HTTPErrorClass
		// Err describes the specific error occurrence.
		Err string `json:"err" xml:"err"`
	}

	// HTTPErrorClass contains information sent together with the error message in responses.
	HTTPErrorClass struct {
		// ID identifies the class of errors for clients.
		ID int `json:"id" xml:"id"`
		// Title is a human friendly title for the class of errors.
		Title string `json:"title" xml:"title"`
		// Status is the HTTP status code used by responses that cary the error.
		Status int `json:"-" xml:"-"`
	}

	// MultiError is an error composed of potentially multiple errors.
	MultiError []error
)

const (
	// ErrInvalidParamType is the error produced by the generated code when
	// a request parameter type does not match the design.
	ErrInvalidParamType = iota

	// ErrMissingParam is the error produced by the generated code when a
	// required request parameter is missing.
	ErrMissingParam

	// ErrInvalidAttributeType is the error produced by the generated
	// code when a data structure attribute type does not match the design
	// definition.
	ErrInvalidAttributeType

	// ErrMissingAttribute is the error produced by the generated
	// code when a data structure attribute required by the design
	// definition is missing.
	ErrMissingAttribute

	// ErrInvalidEnumValue is the error produced by the generated code when
	// a values does not match one of the values listed in the attribute
	// definition as being valid (i.e. not part of the enum).
	ErrInvalidEnumValue

	// ErrMissingHeader is the error produced by the generated code when a
	// required header is missing.
	ErrMissingHeader

	// ErrInvalidFormat is the error produced by the generated code when
	// a value does not match the format specified in the attribute
	// definition.
	ErrInvalidFormat

	// ErrInvalidPattern is the error produced by the generated code when
	// a value does not match the regular expression specified in the
	// attribute definition.
	ErrInvalidPattern

	// ErrInvalidRange is the error produced by the generated code when
	// a value is less than the minimum specified in the design definition
	// or more than the maximum.
	ErrInvalidRange

	// ErrInvalidLength is the error produced by the generated code when
	// a value is a slice with less elements than the minimum length
	// specified in the design definition or more elements than the
	// maximum length.
	ErrInvalidLength

	// ErrInvalidEncoding is the error produced when a request body fails
	// to be decoded.
	ErrInvalidEncoding

	// ErrInternal is the error produced when unexpected conditions
	// occur (i.e. bug).
	ErrInternal
)

// CAUTION: classes must be listed in the order as the constants above.
var classes = []*HTTPErrorClass{
	{ErrInvalidParamType, "invalid parameter value", 400},
	{ErrMissingParam, "missing required parameter", 400},
	{ErrInvalidAttributeType, "invalid attribute type", 400},
	{ErrMissingAttribute, "missing required attribute", 400},
	{ErrInvalidEnumValue, "invalid value", 400},
	{ErrMissingHeader, "missing required HTTP header", 400},
	{ErrInvalidFormat, "value does not match validation format", 400},
	{ErrInvalidPattern, "value does not match validation pattern", 400},
	{ErrInvalidRange, "invalid value range", 400},
	{ErrInvalidLength, "invalid value length", 400},
	{ErrInvalidEncoding, "invalid request encoding", 400},
	{ErrInternal, "internal error", 500},
}

// InvalidParamTypeError creates a HTTPError with class ID ErrInvalidParamType
func InvalidParamTypeError(name string, val interface{}, expected string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidParamType],
		Err: fmt.Sprintf("invalid value %#v for parameter %#v, must be a %s",
			val, name, expected),
	}
	return BuildError(err, herr)
}

// MissingParamError creates a HTTPError with class ID ErrMissingParam
func MissingParamError(name string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrMissingParam],
		Err:            fmt.Sprintf("missing required parameter %#v", name),
	}
	return BuildError(err, herr)
}

// InvalidAttributeTypeError creates a HTTPError with class ID ErrInvalidAttributeType
func InvalidAttributeTypeError(ctx string, val interface{}, expected string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidAttributeType],
		Err: fmt.Sprintf("type of %s must be %s but got value %#v", ctx,
			expected, val),
	}
	return BuildError(err, herr)
}

// MissingAttributeError creates a HTTPError with class ID ErrMissingAttribute
func MissingAttributeError(ctx, name string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrMissingAttribute],
		Err:            fmt.Sprintf("attribute %#v of %s is missing and required", name, ctx),
	}
	return BuildError(err, herr)
}

// MissingHeaderError creates a HTTPError with class ID ErrMissingHeader
func MissingHeaderError(name string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrMissingHeader],
		Err:            fmt.Sprintf("missing required HTTP header %#v", name),
	}
	return BuildError(err, herr)
}

// InvalidEnumValueError creates a HTTPError with class ID ErrInvalidEnumValue
func InvalidEnumValueError(ctx string, val interface{}, allowed []interface{}, err error) error {
	elems := make([]string, len(allowed))
	for i, a := range allowed {
		elems[i] = fmt.Sprintf("%#v", a)
	}
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidEnumValue],
		Err: fmt.Sprintf("value of %s must be one of %s but got value %#v", ctx,
			strings.Join(elems, ", "), val),
	}
	return BuildError(err, herr)
}

// InvalidFormatError creates a HTTPError with class ID ErrInvalidFormat
func InvalidFormatError(ctx, target string, format Format, formatError, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidFormat],
		Err: fmt.Sprintf("%s must be formatted as a %s but got value %#v, %s",
			ctx, format, target, formatError.Error()),
	}
	return BuildError(err, herr)
}

// InvalidPatternError creates a HTTPError with class ID ErrInvalidPattern
func InvalidPatternError(ctx, target string, pattern string, err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidPattern],
		Err: fmt.Sprintf("%s must match the regexp %#v but got value %#v",
			ctx, pattern, target),
	}
	return BuildError(err, herr)
}

// InvalidRangeError creates a HTTPError with class ID ErrInvalidRange
func InvalidRangeError(ctx string, target interface{}, value int, min bool, err error) error {
	comp := "greater or equal"
	if !min {
		comp = "lesser or equal"
	}
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidRange],
		Err: fmt.Sprintf("%s must be %s than %d but got value %#v",
			ctx, comp, value, target),
	}
	return BuildError(err, herr)
}

// InvalidLengthError creates a HTTPError with class ID ErrInvalidLength
func InvalidLengthError(ctx string, target interface{}, ln, value int, min bool, err error) error {
	comp := "greater or equal"
	if !min {
		comp = "lesser or equal"
	}
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidLength],
		Err: fmt.Sprintf("length of %s must be %s than %d but got value %#v (len=%d)",
			ctx, comp, value, target, ln),
	}
	return BuildError(err, herr)
}

// InvalidEncoding creates a HTTPError with class ID ErrInvalidEncoding
func InvalidEncoding(err error) error {
	herr := &HTTPError{
		HTTPErrorClass: classes[ErrInvalidEncoding],
		Err:            err.Error(),
	}
	return BuildError(err, herr)
}

// Error returns the error occurrence details.
func (e *HTTPError) Error() string {
	return e.Err
}

// Error returns the multiple error messages.
func (m MultiError) Error() string {
	errs := make([]string, len(m))
	for i, err := range m {
		errs[i] = err.Error()
	}
	return strings.Join(errs, ", ")
}

// Status computes a status from all the HTTP errors.
// The algorithms returns 500 if any error in the multi error is not a HTTPError or has status 500.
// If all errors are http errors and they all have the same status that status is returned.
// Otherwise Status returns 400.
func (m MultiError) Status() int {
	if len(m) == 0 {
		return 500 // bug
	}
	var status int
	if he, ok := m[0].(*HTTPError); ok {
		status = he.Status
	} else {
		return 500
	}
	if len(m) == 1 {
		return status
	}
	for _, e := range m[1:] {
		if he, ok := e.(*HTTPError); ok {
			if he.Status == 500 {
				return 500
			}
			if he.Status != status {
				status = 400
			}
		} else {
			return 500
		}
	}
	return status
}

// BuildError coerces the first argument into a MultiError then appends the second argument and
// returns the resulting MultiError.
func BuildError(err error, err2 error) error {
	if err == nil {
		if err2 == nil {
			return MultiError{}
		}
		if _, ok := err2.(MultiError); ok {
			return err2
		}
		return MultiError{err2}
	}
	merr, ok := err.(MultiError)
	if err2 == nil {
		if ok {
			return merr
		}
		return MultiError{err}
	}
	merr2, ok2 := err2.(MultiError)
	if ok {
		if ok2 {
			return append(merr, merr2...)
		}
		return append(merr, err2)
	}
	merr = MultiError{err}
	if ok2 {
		return append(merr, merr2...)
	}
	return append(merr, err2)
}
